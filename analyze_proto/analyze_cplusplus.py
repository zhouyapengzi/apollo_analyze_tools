import os
import sre_compile

project_path = "/Users/zipeng/Projects/"
repo_path = "/Users/zipeng/Projects/apollo/"


_regexp_compile_cache = {}
def match(pattern, s):
    """Matches the string with the pattern, caching the compiled regexp."""
    # The regexp compilation caching is inlined in both Match and Search for
    # performance reasons; factoring it out into a separate function turns out
    # to be noticeably expensive.
    if pattern not in _regexp_compile_cache:
        _regexp_compile_cache[pattern] = sre_compile.compile(pattern)
    return _regexp_compile_cache[pattern].match(s)


_regexp_compile_cache = {}
def search(pattern, s):
    """Searches the string for the pattern, caching the compiled regexp."""
    if pattern not in _regexp_compile_cache:
        _regexp_compile_cache[pattern] = sre_compile.compile(pattern)
    return _regexp_compile_cache[pattern].search(s)


# find functions generated by ProtoBuff for each proto file
# check .pb.h + .pb.cc is enough
def function_declaration_in_file(cfile):
    regexp = r'(\w(\w|::|\*|\&|\s)*)\('  # decls * & space::name( ...

    fun_list = set()
    with open(cfile) as f:
        lines = f.readlines()
    for line in lines:
        match_result = match(regexp, line)
        if match_result:
            # If the name is all caps and underscores, figure it's a macro and
            # ignore it, unless it's TEST or TEST_F.
            function_name = match_result.group(1).split()[-1]
            if '_internal' not in function_name.lower():
                fun_list.add(function_name)
    return fun_list


# scan cc file, check which function it calls
def function_calls_in_file(cfile):
    call_functions = set()
    with open(cfile) as f:
        lines = f.readlines()
    for line in lines:
        groups = line.split()
        for g in groups:
            fncall = g  # if there's no control flow construct, look at whole line
            if (  # Ignore control structures.
                    not search(r'\b(if|for|while|switch|new|delete|catch)\b', fncall) and
                    # Ignore pointers/references to functions.
                    not search(r' \([^)]+\)\([^)]*(\)|,$)', fncall) and
                    # Ignore pointers/references to arrays.
                    not search(r' \([^)]+\)\[[^\]]+\]', fncall)):
                search_result = search(r'\w\s*\(.*\)', fncall)
                if search_result:
                    call_functions.add(search_result.string)
    return call_functions






if __name__=="__main__":
    print()
